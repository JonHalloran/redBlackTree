{"version":3,"sources":["webpack:///webpack/bootstrap 3e28868b08eeca72cdfc","webpack:///./index.js","webpack:///./binaryTree.js","webpack:///./vertex.js","webpack:///./Treant.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;;;AC7DA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,qC;;;;;;;;ACxDA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qE;;;;;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;AC9KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,OAAO;AAC1B,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA,OAAO,gCAAgC;AACvC;AACA,OAAO,2BAA2B;AAClC;AACA,OAAO,OAAO;AACd;AACA;AACA,KAAK;;AAEL;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,mBAAmB,SAAS;AAC5B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,mBAAmB,SAAS;AAC5B,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kDAAkD;;AAElD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA;AACA,KAAK;;AAEL;AACA,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,KAAK;;AAEL;AACA,mBAAmB,SAAS;AAC5B,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,mBAAmB,SAAS;AAC5B,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA,iDAAiD,OAAO;AACxD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,SAAS,+BAA+B;AACxC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;;AAEA,0BAA0B;AAC1B;AACA,0BAA0B;AAC1B,WAAW;AACX,0DAA0D;AAC1D;;AAEA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C,SAAS;;AAEvD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA,SAAS,OAAO;AAChB;AACA;AACA;AACA;;AAEA;AACA,sDAAsD;AACtD,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP,oDAAoD;AACpD;AACA;;AAEA,sDAAsD;AACtD,iDAAiD;AACjD;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,kBAAkB,qCAAqC;;AAEvD;AACA,SAAS;AACT;AACA;;AAEA,qBAAqB,qCAAqC;;AAE1D;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;AACA,mBAAmB,SAAS;AAC5B,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA,wDAAwD;AACxD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,6CAA6C;AAC7C;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA,mBAAmB,SAAS;AAC5B,mBAAmB,SAAS;AAC5B,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,OAAO;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,mBAAmB,SAAS;AAC5B,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,mBAAmB,SAAS;AAC5B,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,KAAK;AACxB,qBAAqB;AACrB;AACA;;AAEA;;AAEA;;AAEA;AACA,uBAAuB,OAAO;AAC9B,uBAAuB,OAAO;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC;;AAEzC;;AAEA;AACA,KAAK;;AAEL;AACA,mBAAmB,KAAK;AACxB,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA,6BAA6B;AAC7B,KAAK;;AAEL;AACA,mBAAmB,SAAS;AAC5B,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,KAAK;AACxB,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL,oDAAoD;AACpD;AACA;;AAEA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,KAAK;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,KAAK;AACxB,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,0EAA0E;;AAE1E;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA,qBAAqB;AACrB;AACA;AACA;AACA,KAAK;;AAEL;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,qBAAqB;AACrB;AACA;AACA;AACA,KAAK;;AAEL;AACA,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA;AACA,KAAK;;AAEL;AACA,qBAAqB;AACrB;AACA;AACA;AACA,KAAK;;AAEL;AACA,qBAAqB;AACrB;AACA;AACA;AACA,KAAK;;AAEL;AACA,qBAAqB;AACrB;AACA;AACA;AACA,KAAK;;AAEL;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,OAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B;AAC/B;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,qBAAqB;AACrB;AACA,oCAAoC;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,mBAAmB,OAAO;AAC1B;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;;AAEA,yCAAyC;AACzC;;AAEA;;AAEA;;AAEA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe,KAAK;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;;AAEL,WAAW;;AAEX;AACA;AACA;AACA;AACA,KAAK;;AAEL,gBAAgB;AAChB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,uDAAuD;AACvD,gFAAgF;AAChF,8EAA8E;AAC9E,kEAAkE;AAClE,2FAA2F;AAC3F,4FAA4F;AAC5F,oEAAoE;AACpE,iEAAiE;AACjE,kEAAkE;AAClE,8CAA8C;AAC9C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,SAAS;AACvB;AACA,mEAAmE;;AAEnE;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 3e28868b08eeca72cdfc","import BinaryTree from \"./binaryTree\";\nimport Treant from \"./Treant\";\n\nlet tree = new BinaryTree();\ntree.addVertex(50);\n// tree.addVertex(44); tree.addVertex(94);\ntree.addVertex(3);\n// tree.addVertex(80);\ntree.addVertex(3);\n\nlet button = document.getElementsByClassName('data')[0];\nbutton.addEventListener(\"click\", () => {\n  let value = Math.floor(Math.random(100) * 100);\n  newNode(value);\n  console.log(\"newValue\", value);\n  tree.addVertex(value);\n  treeStructure[\"nodeStructure\"] = tree.printNodes(tree.root);\n  window.Treant(treeStructure);\n});\n\nlet form = document.getElementsByClassName('add-node')[0];\nform.addEventListener(\"submit\", (e) => {\n  e.preventDefault();\n  newNode(e.target[0].value);\n});\n\nconst newNode = (value) => {\n  tree.addVertex(value);\n  treeStructure[\"nodeStructure\"] = tree.printNodes(tree.root);\n  window.Treant(treeStructure);\n};\n\nvar treeStructure = {\n  chart: {\n    container: \"#red-black-tree\",\n    levelSeparation: 20,\n    siblingSeparation: 5,\n    subTeeSeparation: 5,\n    rootOrientation: \"NORTH\",\n\n    node: {\n      HTMLclass: \"\",\n      drawLineThrough: false\n    },\n    connectors: {\n      type: \"straight\",\n      style: {\n        \"stroke-width\": 2,\n        \"stroke\": \"#000000\"\n      }\n    }\n  },\n\n  nodeStructure: tree.printNodes(tree.root)\n};\n\nwindow.treeStructure = treeStructure;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./index.js\n// module id = 0\n// module chunks = 0","import Vertex from './vertex';\n\nconst blankNode = {\n  text: {\n    val: ''\n  },\n  HTMLclass: \"BLACK null\",\n  connectors: {\n    style: {\n      'stroke': '#ffffff',\n      \"stroke-dasharray\": \"- .\", //\"\", \"-\", \".\", \"-.\", \"-..\", \". \", \"- \", \"--\", \"- .\", \"--.\", \"--..\"\n      'arrow-start': 'classic-wide-long'\n    }\n  }\n};\nclass BinaryTree {\n  constructor() {\n    this.root = undefined;\n    this.left = undefined;\n    this.right = undefined;\n  }\n\n  addVertex(value) {\n    if (!this.root) {\n      this.root = new Vertex(undefined, value);\n      this\n        .root\n        .checkRed();\n    } else {\n      this\n        .root\n        .addVertex(value);\n    }\n    this.newRoot(this.root);\n  }\n\n  newRoot(node) {\n    if (node.parent) {\n      this.root = node.parent;\n      this.newRoot(this.root);\n    }\n  }\n\n  printNodes(node) {\n    if (node === undefined) \n      return undefined;\n    let jason = {\n      text: {\n        val: node.value\n      },\n      HTMLclass: node.color\n      // innerHTML: node.value\n    };\n\n    jason[\"children\"] = [blankNode, blankNode];\n    if (node.left || node.right) {\n      if (node.left) \n        jason[\"children\"][0] = this.printNodes(node.left);\n      if (node.right) \n        jason[\"children\"][1] = this.printNodes(node.right);\n      }\n    return jason;\n  }\n}\n\nexport default BinaryTree;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./binaryTree.js\n// module id = 1\n// module chunks = 0","class Vertex {\n  constructor(parent, value) {\n    console.log(\"parent\", parent);\n    this.parent = parent;\n    this.value = value;\n    this.color = \"RED\";\n    this.left = undefined;\n    this.right = undefined;\n    if (this.parent) \n      console.log(\"preRed\", this.parent.left);\n    }\n  \n  get isRoot() {\n    return this.parent === undefined;\n  }\n\n  get isRightChild() {\n    return this.parent\n      ? this.parent.right === this\n      : false;\n  }\n\n  get grandparent() {\n    return this.parent\n      ? this.parent.parent\n      : undefined;\n  }\n\n  get uncle() {\n    return this.grandparent\n      ? (this.parent.isRightChild\n        ? this.grandparent.left\n        : this.grandparent.right)\n      : undefined;\n  }\n\n  get isLeaf() {\n    return this.right && this.left;\n  }\n\n  leftRotate() {\n    console.log(\"leftRotate\", this);\n    if (this.parent) {\n      this.isRightChild\n        ? this.parent.right = this.right\n        : this.parent.left = this.right;\n    }\n    if (this.right) \n      this.right.parent = this.parent;\n    this.parent = this.right;\n    this.right = this.parent.left;\n    this.parent.left = this;\n    if (this.right) \n      this.right.parent = this;\n\n    }\n  \n  rightRotate() {\n    console.log(\"rightRotate\", this);\n    if (this.parent) {\n      this.isRightChild\n        ? this.parent.right = this.left\n        : this.parent.left = this.left;\n    }\n    if (this.left) \n      this.left.parent = this.parent;\n    this.parent = this.left;\n    this.left = this.parent.right;\n    this.parent.right = this;\n    if (this.left) \n      this.left.parent = this;\n\n    }\n  \n  addVertex(value) {\n    if (value < this.value) {\n      if (this.left) {\n        this\n          .left\n          .addVertex(value);\n      } else {\n        this.left = new Vertex(this, value);\n        this\n          .left\n          .checkRed();\n      }\n\n    } else {\n      if (this.right) {\n        this\n          .right\n          .addVertex(value);\n      } else {\n        this.right = new Vertex(this, value);\n        this\n          .right\n          .checkRed();\n      }\n    }\n  }\n\n  checkRed() {\n    console.log(\"checkRed\", this.isRoot);\n    if (this.isRoot) {\n      // Case 0\n      this.color = \"BLACK\";\n    } else if (this.parent.color === \"RED\") {\n      console.log(this.uncle, \"uncle\");\n      if (this.uncle && this.uncle.color === \"RED\") {\n        this.caseOne();\n      } else {\n        console.log(\"self Right child\", this.isRightChild, this.value, this.parent.value);\n        console.log(\"parent Right child\", this.parent.isRightChild, this.parent.value, this.parent.parent.value);\n        const rightLine = this.isRightChild && this.parent.isRightChild;\n        const leftLine = !this.isRightChild && !this.parent.isRightChild;\n        console.log(leftLine, rightLine);\n        if (rightLine || leftLine) {\n          this.caseThree();\n        } else {\n          this.caseTwo();\n        }\n      }\n    }\n  }\n\n  caseOne() {\n    console.log(\"CaseOne\");\n    // recolor only\n    this.grandparent.color = \"RED\";\n    this.uncle.color = \"BLACK\";\n    console.log(\"uncle \", this.uncle);\n    this.parent.color = \"BLACK\";\n    this\n      .grandparent\n      .checkRed();\n  }\n\n  caseTwo() {\n    console.log(\"caseTwo\");\n    if (this.isRightChild) {\n      this\n        .parent\n        .leftRotate();\n      this\n        .left\n        .checkRed();\n    } else {\n      this\n        .parent\n        .rightRotate();\n      this\n        .right\n        .checkRed();\n    }\n  }\n\n  caseThree() {\n    console.log(\"caseThree\");\n    if (this.parent.isRightChild) {\n      this\n        .grandparent\n        .leftRotate();\n    } else {\n      this\n        .grandparent\n        .rightRotate();\n    }\n\n    this.parent.color = \"BLACK\";\n    this.parent.left.color = \"RED\";\n    this.parent.right.color = \"RED\";\n  }\n\n}\nexport default Vertex;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./vertex.js\n// module id = 2\n// module chunks = 0","/*\n * Treant-js\n *\n * (c) 2013 Fran Peručić\n * Treant-js may be freely distributed under the MIT license.\n * For all details and documentation:\n * http://fperucic.github.io/treant-js\n *\n * Treant is an open-source JavaScipt library for visualization of tree diagrams.\n * It implements the node positioning algorithm of John Q. Walker II \"Positioning nodes for General Trees\".\n *\n * References:\n * Emilio Cortegoso Lobato: ECOTree.js v1.0 (October 26th, 2006)\n *\n * Contributors:\n * Fran Peručić, https://github.com/fperucic\n * Dave Goodchild, https://github.com/dlgoodchild\n */\n(function () {\n  // Polyfill for IE to use startsWith\n  if (!String.prototype.startsWith) {\n    String.prototype.startsWith = function (searchString, position) {\n      return this.substr(position || 0, searchString.length) === searchString;\n    };\n  }\n\n  var $ = null;\n\n  var UTIL = {\n\n    /**\n         * Directly updates, recursively/deeply, the first object with all properties in the second object\n         * @param {object} applyTo\n         * @param {object} applyFrom\n         * @return {object}\n         */\n    inheritAttrs: function (applyTo, applyFrom) {\n      for (var attr in applyFrom) {\n        if (applyFrom.hasOwnProperty(attr)) {\n          if ((applyTo[attr]instanceof Object && applyFrom[attr]instanceof Object) && (typeof applyFrom[attr] !== 'function')) {\n            this.inheritAttrs(applyTo[attr], applyFrom[attr]);\n          } else {\n            applyTo[attr] = applyFrom[attr];\n          }\n        }\n      }\n      return applyTo;\n    },\n\n    /**\n         * Returns a new object by merging the two supplied objects\n         * @param {object} obj1\n         * @param {object} obj2\n         * @returns {object}\n         */\n    createMerge: function (obj1, obj2) {\n      var newObj = {};\n      if (obj1) {\n        this.inheritAttrs(newObj, this.cloneObj(obj1));\n      }\n      if (obj2) {\n        this.inheritAttrs(newObj, obj2);\n      }\n      return newObj;\n    },\n\n    /**\n         * Takes any number of arguments\n         * @returns {*}\n         */\n    extend: function () {\n      if ($) {\n        Array\n          .prototype\n          .unshift\n          .apply(arguments, [true, {}]);\n        return $\n          .extend\n          .apply($, arguments);\n      } else {\n        return UTIL\n          .createMerge\n          .apply(this, arguments);\n      }\n    },\n\n    /**\n         * @param {object} obj\n         * @returns {*}\n         */\n    cloneObj: function (obj) {\n      if (Object(obj) !== obj) {\n        return obj;\n      }\n      var res = new obj.constructor();\n      for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          res[key] = this.cloneObj(obj[key]);\n        }\n      }\n      return res;\n    },\n\n    /**\n         * @param {Element} el\n         * @param {string} eventType\n         * @param {function} handler\n         */\n    addEvent: function (el, eventType, handler) {\n      if ($) {\n        $(el).on(eventType + '.treant', handler);\n      } else if (el.addEventListener) { // DOM Level 2 browsers\n        el.addEventListener(eventType, handler, false);\n      } else if (el.attachEvent) { // IE <= 8\n        el.attachEvent('on' + eventType, handler);\n      } else { // ancient browsers\n        el['on' + eventType] = handler;\n      }\n    },\n\n    /**\n         * @param {string} selector\n         * @param {boolean} raw\n         * @param {Element} parentEl\n         * @returns {Element|jQuery}\n         */\n    findEl: function (selector, raw, parentEl) {\n      parentEl = parentEl || document;\n\n      if ($) {\n        var $element = $(selector, parentEl);\n        return (raw\n          ? $element.get(0)\n          : $element);\n      } else {\n        // todo: getElementsByName()\n        // todo: getElementsByTagName()\n        // todo: getElementsByTagNameNS()\n        if (selector.charAt(0) === '#') {\n          return parentEl.getElementById(selector.substring(1));\n        } else if (selector.charAt(0) === '.') {\n          var oElements = parentEl.getElementsByClassName(selector.substring(1));\n          return (oElements.length\n            ? oElements[0]\n            : null);\n        }\n\n        throw new Error('Unknown container element');\n      }\n    },\n\n    getOuterHeight: function (element) {\n      var nRoundingCompensation = 1;\n      if (typeof element.getBoundingClientRect === 'function') {\n        return element\n          .getBoundingClientRect()\n          .height;\n      } else if ($) {\n        return Math.ceil($(element).outerHeight()) + nRoundingCompensation;\n      } else {\n        return Math.ceil(element.clientHeight + UTIL.getStyle(element, 'border-top-width', true) + UTIL.getStyle(element, 'border-bottom-width', true) + UTIL.getStyle(element, 'padding-top', true) + UTIL.getStyle(element, 'padding-bottom', true) + nRoundingCompensation);\n      }\n    },\n\n    getOuterWidth: function (element) {\n      var nRoundingCompensation = 1;\n      if (typeof element.getBoundingClientRect === 'function') {\n        return element\n          .getBoundingClientRect()\n          .width;\n      } else if ($) {\n        return Math.ceil($(element).outerWidth()) + nRoundingCompensation;\n      } else {\n        return Math.ceil(element.clientWidth + UTIL.getStyle(element, 'border-left-width', true) + UTIL.getStyle(element, 'border-right-width', true) + UTIL.getStyle(element, 'padding-left', true) + UTIL.getStyle(element, 'padding-right', true) + nRoundingCompensation);\n      }\n    },\n\n    getStyle: function (element, strCssRule, asInt) {\n      var strValue = \"\";\n      if (document.defaultView && document.defaultView.getComputedStyle) {\n        strValue = document\n          .defaultView\n          .getComputedStyle(element, '')\n          .getPropertyValue(strCssRule);\n      } else if (element.currentStyle) {\n        strCssRule = strCssRule.replace(/\\-(\\w)/g, function (strMatch, p1) {\n          return p1.toUpperCase();\n        });\n        strValue = element.currentStyle[strCssRule];\n      }\n      //Number(elem.style.width.replace(/[^\\d\\.\\-]/g, ''));\n      return (asInt\n        ? parseFloat(strValue)\n        : strValue);\n    },\n\n    addClass: function (element, cssClass) {\n      if ($) {\n        $(element).addClass(cssClass);\n      } else {\n        if (!UTIL.hasClass(element, cssClass)) {\n          if (element.classList) {\n            element\n              .classList\n              .add(cssClass);\n          } else {\n            element.className += \" \" + cssClass;\n          }\n        }\n      }\n    },\n\n    hasClass: function (element, my_class) {\n      return (\" \" + element.className + \" \")\n        .replace(/[\\n\\t]/g, \" \")\n        .indexOf(\" \" + my_class + \" \") > -1;\n    },\n\n    toggleClass: function (element, cls, apply) {\n      if ($) {\n        $(element).toggleClass(cls, apply);\n      } else {\n        if (apply) {\n          //element.className += \" \"+cls;\n          element\n            .classList\n            .add(cls);\n        } else {\n          element\n            .classList\n            .remove(cls);\n        }\n      }\n    },\n\n    setDimensions: function (element, width, height) {\n      if ($) {\n        $(element)\n          .width(width)\n          .height(height);\n      } else {\n        element.style.width = width + 'px';\n        element.style.height = height + 'px';\n      }\n    },\n    isjQueryAvailable: function () {\n      return (typeof($) !== 'undefined' && $);\n    }\n  };\n\n  /**\n     * ImageLoader is used for determining if all the images from the Tree are loaded.\n     * Node size (width, height) can be correctly determined only when all inner images are loaded\n     */\n  var ImageLoader = function () {\n    this.reset();\n  };\n\n  ImageLoader.prototype = {\n\n    /**\n         * @returns {ImageLoader}\n         */\n    reset: function () {\n      this.loading = [];\n      return this;\n    },\n\n    /**\n         * @param {TreeNode} node\n         * @returns {ImageLoader}\n         */\n    processNode: function (node) {\n      var aImages = node\n        .nodeDOM\n        .getElementsByTagName('img');\n\n      var i = aImages.length;\n      while (i--) {\n        this.create(node, aImages[i]);\n      }\n      return this;\n    },\n\n    /**\n         * @returns {ImageLoader}\n         */\n    removeAll: function (img_src) {\n      var i = this.loading.length;\n      while (i--) {\n        if (this.loading[i] === img_src) {\n          this\n            .loading\n            .splice(i, 1);\n        }\n      }\n      return this;\n    },\n\n    /**\n         * @param {TreeNode} node\n         * @param {Element} image\n         * @returns {*}\n         */\n    create: function (node, image) {\n      var self = this,\n        source = image.src;\n\n      function imgTrigger() {\n        self.removeAll(source);\n        node.width = node.nodeDOM.offsetWidth;\n        node.height = node.nodeDOM.offsetHeight;\n      }\n\n      if (image.src.indexOf('data:') !== 0) {\n        this\n          .loading\n          .push(source);\n\n        if (image.complete) {\n          return imgTrigger();\n        }\n\n        UTIL.addEvent(image, 'load', imgTrigger);\n        UTIL.addEvent(image, 'error', imgTrigger); // handle broken url-s\n\n        // load event is not fired for cached images, force the load event\n        image.src += ((image.src.indexOf('?') > 0)\n          ? '&'\n          : '?') + new Date().getTime();\n      } else {\n        imgTrigger();\n      }\n    },\n\n    /**\n         * @returns {boolean}\n         */\n    isNotLoading: function () {\n      return (this.loading.length === 0);\n    }\n  };\n\n  /**\n     * Class: TreeStore\n     * TreeStore is used for holding initialized Tree objects\n     *  Its purpose is to avoid global variables and enable multiple Trees on the page.\n     */\n  var TreeStore = {\n\n    store: [],\n\n    /**\n         * @param {object} jsonConfig\n         * @returns {Tree}\n         */\n    createTree: function (jsonConfig) {\n      var nNewTreeId = this.store.length;\n      this\n        .store\n        .push(new Tree(jsonConfig, nNewTreeId));\n      return this.get(nNewTreeId);\n    },\n\n    /**\n         * @param {number} treeId\n         * @returns {Tree}\n         */\n    get: function (treeId) {\n      return this.store[treeId];\n    },\n\n    /**\n         * @param {number} treeId\n         * @returns {TreeStore}\n         */\n    destroy: function (treeId) {\n      var tree = this.get(treeId);\n      if (tree) {\n        tree\n          ._R\n          .remove();\n        var draw_area = tree.drawArea;\n\n        while (draw_area.firstChild) {\n          draw_area.removeChild(draw_area.firstChild);\n        }\n\n        var classes = draw_area\n            .className\n            .split(' '),\n          classes_to_stay = [];\n\n        for (var i = 0; i < classes.length; i++) {\n          var cls = classes[i];\n          if (cls !== 'Treant' && cls !== 'Treant-loaded') {\n            classes_to_stay.push(cls);\n          }\n        }\n        draw_area.style.overflowY = '';\n        draw_area.style.overflowX = '';\n        draw_area.className = classes_to_stay.join(' ');\n\n        this.store[treeId] = null;\n      }\n      return this;\n    }\n  };\n\n  /**\n     * Tree constructor.\n     * @param {object} jsonConfig\n     * @param {number} treeId\n     * @constructor\n     */\n  var Tree = function (jsonConfig, treeId) {\n\n    /**\n         * @param {object} jsonConfig\n         * @param {number} treeId\n         * @returns {Tree}\n         */\n    this.reset = function (jsonConfig, treeId) {\n      this.initJsonConfig = jsonConfig;\n      this.initTreeId = treeId;\n\n      this.id = treeId;\n\n      this.CONFIG = UTIL.extend(Tree.CONFIG, jsonConfig.chart);\n      this.drawArea = UTIL.findEl(this.CONFIG.container, true);\n      if (!this.drawArea) {\n        throw new Error('Failed to find element by selector \"' + this.CONFIG.container + '\"');\n      }\n\n      UTIL.addClass(this.drawArea, 'Treant');\n\n      // kill of any child elements that may be there\n      this.drawArea.innerHTML = '';\n\n      this.imageLoader = new ImageLoader();\n\n      this.nodeDB = new NodeDB(jsonConfig.nodeStructure, this);\n\n      // key store for storing reference to node connectors, key = nodeId where the\n      // connector ends\n      this.connectionStore = {};\n\n      this.loaded = false;\n\n      this._R = new Raphael(this.drawArea, 100, 100);\n\n      return this;\n    };\n\n    /**\n         * @returns {Tree}\n         */\n    this.reload = function () {\n      this\n        .reset(this.initJsonConfig, this.initTreeId)\n        .redraw();\n      return this;\n    };\n\n    this.reset(jsonConfig, treeId);\n  };\n\n  Tree.prototype = {\n\n    /**\n         * @returns {NodeDB}\n         */\n    getNodeDb: function () {\n      return this.nodeDB;\n    },\n\n    /**\n         * @param {TreeNode} parentTreeNode\n         * @param {object} nodeDefinition\n         * @returns {TreeNode}\n         */\n    addNode: function (parentTreeNode, nodeDefinition) {\n      var dbEntry = this\n        .nodeDB\n        .get(parentTreeNode.id);\n\n      this\n        .CONFIG\n        .callback\n        .onBeforeAddNode\n        .apply(this, [parentTreeNode, nodeDefinition]);\n\n      var oNewNode = this\n        .nodeDB\n        .createNode(nodeDefinition, parentTreeNode.id, this);\n      oNewNode.createGeometry(this);\n\n      oNewNode\n        .parent()\n        .createSwitchGeometry(this);\n\n      this.positionTree();\n\n      this\n        .CONFIG\n        .callback\n        .onAfterAddNode\n        .apply(this, [oNewNode, parentTreeNode, nodeDefinition]);\n\n      return oNewNode;\n    },\n\n    /**\n         * @returns {Tree}\n         */\n    redraw: function () {\n      this.positionTree();\n      return this;\n    },\n\n    /**\n         * @param {function} callback\n         * @returns {Tree}\n         */\n    positionTree: function (callback) {\n      var self = this;\n\n      if (this.imageLoader.isNotLoading()) {\n        var root = this.root(),\n          orient = this.CONFIG.rootOrientation;\n\n        this.resetLevelData();\n\n        this.firstWalk(root, 0);\n        this.secondWalk(root, 0, 0, 0);\n\n        this.positionNodes();\n\n        if (this.CONFIG.animateOnInit) {\n          setTimeout(function () {\n            root.toggleCollapse();\n          }, this.CONFIG.animateOnInitDelay);\n        }\n\n        if (!this.loaded) {\n          UTIL.addClass(this.drawArea, 'Treant-loaded'); // nodes are hidden until .loaded class is added\n          if (Object.prototype.toString.call(callback) === \"[object Function]\") {\n            callback(self);\n          }\n          self\n            .CONFIG\n            .callback\n            .onTreeLoaded\n            .apply(self, [root]);\n          this.loaded = true;\n        }\n\n      } else {\n        setTimeout(function () {\n          self.positionTree(callback);\n        }, 10);\n      }\n      return this;\n    },\n\n    /**\n         * In a first post-order walk, every node of the tree is assigned a preliminary\n         * x-coordinate (held in field node->prelim).\n         * In addition, internal nodes are given modifiers, which will be used to move their\n         * children to the right (held in field node->modifier).\n         * @param {TreeNode} node\n         * @param {number} level\n         * @returns {Tree}\n         */\n    firstWalk: function (node, level) {\n      node.prelim = null;\n      node.modifier = null;\n\n      this.setNeighbors(node, level);\n      this.calcLevelDim(node, level);\n\n      var leftSibling = node.leftSibling();\n\n      if (node.childrenCount() === 0 || level == this.CONFIG.maxDepth) {\n        // set preliminary x-coordinate\n        if (leftSibling) {\n          node.prelim = leftSibling.prelim + leftSibling.size() + this.CONFIG.siblingSeparation;\n        } else {\n          node.prelim = 0;\n        }\n      } else {\n        //node is not a leaf,  firstWalk for each child\n        for (var i = 0, n = node.childrenCount(); i < n; i++) {\n          this.firstWalk(node.childAt(i), level + 1);\n        }\n\n        var midPoint = node.childrenCenter() - node.size() / 2;\n\n        if (leftSibling) {\n          node.prelim = leftSibling.prelim + leftSibling.size() + this.CONFIG.siblingSeparation;\n          node.modifier = node.prelim - midPoint;\n          this.apportion(node, level);\n        } else {\n          node.prelim = midPoint;\n        }\n\n        // handle stacked children positioning\n        if (node.stackParent) { // handle the parent of stacked children\n          node.modifier += this\n            .nodeDB\n            .get(node.stackChildren[0])\n            .size() / 2 + node.connStyle.stackIndent;\n        } else if (node.stackParentId) { // handle stacked children\n          node.prelim = 0;\n        }\n      }\n      return this;\n    },\n\n    /*\n         * Clean up the positioning of small sibling subtrees.\n         * Subtrees of a node are formed independently and\n         * placed as close together as possible. By requiring\n         * that the subtrees be rigid at the time they are put\n         * together, we avoid the undesirable effects that can\n         * accrue from positioning nodes rather than subtrees.\n         */\n    apportion: function (node, level) {\n      var firstChild = node.firstChild(),\n        firstChildLeftNeighbor = firstChild.leftNeighbor(),\n        compareDepth = 1,\n        depthToStop = this.CONFIG.maxDepth - level;\n\n      while (firstChild && firstChildLeftNeighbor && compareDepth <= depthToStop) {\n        // calculate the position of the firstChild, according to the position of\n        // firstChildLeftNeighbor\n\n        var modifierSumRight = 0,\n          modifierSumLeft = 0,\n          leftAncestor = firstChildLeftNeighbor,\n          rightAncestor = firstChild;\n\n        for (var i = 0; i < compareDepth; i++) {\n          leftAncestor = leftAncestor.parent();\n          rightAncestor = rightAncestor.parent();\n          modifierSumLeft += leftAncestor.modifier;\n          modifierSumRight += rightAncestor.modifier;\n\n          // all the stacked children are oriented towards right so use right variables\n          if (rightAncestor.stackParent !== undefined) {\n            modifierSumRight += rightAncestor.size() / 2;\n          }\n        }\n\n        // find the gap between two trees and apply it to subTrees and mathing smaller\n        // gaps to smaller subtrees\n\n        var totalGap = (firstChildLeftNeighbor.prelim + modifierSumLeft + firstChildLeftNeighbor.size() + this.CONFIG.subTeeSeparation) - (firstChild.prelim + modifierSumRight);\n\n        if (totalGap > 0) {\n          var subtreeAux = node,\n            numSubtrees = 0;\n\n          // count all the subtrees in the LeftSibling\n          while (subtreeAux && subtreeAux.id !== leftAncestor.id) {\n            subtreeAux = subtreeAux.leftSibling();\n            numSubtrees++;\n          }\n\n          if (subtreeAux) {\n            var subtreeMoveAux = node,\n              singleGap = totalGap / numSubtrees;\n\n            while (subtreeMoveAux.id !== leftAncestor.id) {\n              subtreeMoveAux.prelim += totalGap;\n              subtreeMoveAux.modifier += totalGap;\n\n              totalGap -= singleGap;\n              subtreeMoveAux = subtreeMoveAux.leftSibling();\n            }\n          }\n        }\n\n        compareDepth++;\n\n        firstChild = (firstChild.childrenCount() === 0)\n          ? node.leftMost(0, compareDepth)\n          : firstChild = firstChild.firstChild();\n\n        if (firstChild) {\n          firstChildLeftNeighbor = firstChild.leftNeighbor();\n        }\n      }\n    },\n\n    /*\n         * During a second pre-order walk, each node is given a\n         * final x-coordinate by summing its preliminary\n         * x-coordinate and the modifiers of all the node's\n         * ancestors.  The y-coordinate depends on the height of\n         * the tree.  (The roles of x and y are reversed for\n         * RootOrientations of EAST or WEST.)\n         */\n    secondWalk: function (node, level, X, Y) {\n      if (level <= this.CONFIG.maxDepth) {\n        var xTmp = node.prelim + X,\n          yTmp = Y,\n          align = this.CONFIG.nodeAlign,\n          orient = this.CONFIG.rootOrientation,\n          levelHeight,\n          nodesizeTmp;\n\n        if (orient === 'NORTH' || orient === 'SOUTH') {\n          levelHeight = this.levelMaxDim[level].height;\n          nodesizeTmp = node.height;\n          if (node.pseudo) {\n            node.height = levelHeight;\n          } // assign a new size to pseudo nodes\n        } else if (orient === 'WEST' || orient === 'EAST') {\n          levelHeight = this.levelMaxDim[level].width;\n          nodesizeTmp = node.width;\n          if (node.pseudo) {\n            node.width = levelHeight;\n          } // assign a new size to pseudo nodes\n        }\n\n        node.X = xTmp;\n\n        if (node.pseudo) { // pseudo nodes need to be properly aligned, otherwise position is not correct in some examples\n          if (orient === 'NORTH' || orient === 'WEST') {\n            node.Y = yTmp; // align \"BOTTOM\"\n          } else if (orient === 'SOUTH' || orient === 'EAST') {\n            node.Y = (yTmp + (levelHeight - nodesizeTmp)); // align \"TOP\"\n          }\n\n        } else {\n          node.Y = (align === 'CENTER')\n            ? (yTmp + (levelHeight - nodesizeTmp) / 2)\n            : (align === 'TOP')\n              ? (yTmp + (levelHeight - nodesizeTmp))\n              : yTmp;\n        }\n\n        if (orient === 'WEST' || orient === 'EAST') {\n          var swapTmp = node.X;\n          node.X = node.Y;\n          node.Y = swapTmp;\n        }\n\n        if (orient === 'SOUTH') {\n          node.Y = -node.Y - nodesizeTmp;\n        } else if (orient === 'EAST') {\n          node.X = -node.X - nodesizeTmp;\n        }\n\n        if (node.childrenCount() !== 0) {\n          if (node.id === 0 && this.CONFIG.hideRootNode) {\n            // ako je root node Hiden onda nemoj njegovu dijecu pomaknut po Y osi za Level\n            // separation, neka ona budu na vrhu\n            this.secondWalk(node.firstChild(), level + 1, X + node.modifier, Y);\n          } else {\n            this.secondWalk(node.firstChild(), level + 1, X + node.modifier, Y + levelHeight + this.CONFIG.levelSeparation);\n          }\n        }\n\n        if (node.rightSibling()) {\n          this.secondWalk(node.rightSibling(), level, X, Y);\n        }\n      }\n    },\n\n    /**\n         * position all the nodes, center the tree in center of its container\n         * 0,0 coordinate is in the upper left corner\n         * @returns {Tree}\n         */\n    positionNodes: function () {\n      var self = this,\n        treeSize = {\n          x: self\n            .nodeDB\n            .getMinMaxCoord('X', null, null),\n          y: self\n            .nodeDB\n            .getMinMaxCoord('Y', null, null)\n        },\n\n        treeWidth = treeSize.x.max - treeSize.x.min,\n        treeHeight = treeSize.y.max - treeSize.y.min,\n\n        treeCenter = {\n          x: treeSize.x.max - treeWidth / 2,\n          y: treeSize.y.max - treeHeight / 2\n        };\n\n      this.handleOverflow(treeWidth, treeHeight);\n\n      var containerCenter = {\n          x: self.drawArea.clientWidth / 2,\n          y: self.drawArea.clientHeight / 2\n        },\n\n        deltaX = containerCenter.x - treeCenter.x,\n        deltaY = containerCenter.y - treeCenter.y,\n\n        // all nodes must have positive X or Y coordinates, handle this with offsets\n        negOffsetX = ((treeSize.x.min + deltaX) <= 0)\n          ? Math.abs(treeSize.x.min)\n          : 0,\n        negOffsetY = ((treeSize.y.min + deltaY) <= 0)\n          ? Math.abs(treeSize.y.min)\n          : 0,\n        i,\n        len,\n        node;\n\n      // position all the nodes\n      for (i = 0, len = this.nodeDB.db.length; i < len; i++) {\n\n        node = this\n          .nodeDB\n          .get(i);\n\n        self\n          .CONFIG\n          .callback\n          .onBeforePositionNode\n          .apply(self, [node, i, containerCenter, treeCenter]);\n\n        if (node.id === 0 && this.CONFIG.hideRootNode) {\n          self\n            .CONFIG\n            .callback\n            .onAfterPositionNode\n            .apply(self, [node, i, containerCenter, treeCenter]);\n          continue;\n        }\n\n        // if the tree is smaller than the draw area, then center the tree within\n        // drawing area\n        node.X += negOffsetX + ((treeWidth < this.drawArea.clientWidth)\n          ? deltaX\n          : this.CONFIG.padding);\n        node.Y += negOffsetY + ((treeHeight < this.drawArea.clientHeight)\n          ? deltaY\n          : this.CONFIG.padding);\n\n        var collapsedParent = node.collapsedParent(),\n          hidePoint = null;\n\n        if (collapsedParent) {\n          // position the node behind the connector point of the parent, so future\n          // animations can be visible\n          hidePoint = collapsedParent.connectorPoint(true);\n          node.hide(hidePoint);\n\n        } else if (node.positioned) {\n          // node is already positioned,\n          node.show();\n        } else { // inicijalno stvaranje nodeova, postavi lokaciju\n          node.nodeDOM.style.left = node.X + 'px';\n          node.nodeDOM.style.top = node.Y + 'px';\n          node.positioned = true;\n        }\n\n        if (node.id !== 0 && !(node.parent().id === 0 && this.CONFIG.hideRootNode)) {\n          this.setConnectionToParent(node, hidePoint); // skip the root node\n        } else if (!this.CONFIG.hideRootNode && node.drawLineThrough) {\n          // drawlinethrough is performed for for the root node also\n          node.drawLineThroughMe();\n        }\n\n        self\n          .CONFIG\n          .callback\n          .onAfterPositionNode\n          .apply(self, [node, i, containerCenter, treeCenter]);\n      }\n      return this;\n    },\n\n    /**\n         * Create Raphael instance, (optionally set scroll bars if necessary)\n         * @param {number} treeWidth\n         * @param {number} treeHeight\n         * @returns {Tree}\n         */\n    handleOverflow: function (treeWidth, treeHeight) {\n      var viewWidth = (treeWidth < this.drawArea.clientWidth)\n          ? this.drawArea.clientWidth\n          : treeWidth + this.CONFIG.padding * 2,\n        viewHeight = (treeHeight < this.drawArea.clientHeight)\n          ? this.drawArea.clientHeight\n          : treeHeight + this.CONFIG.padding * 2;\n\n      this\n        ._R\n        .setSize(viewWidth, viewHeight);\n\n      if (this.CONFIG.scrollbar === 'resize') {\n        UTIL.setDimensions(this.drawArea, viewWidth, viewHeight);\n      } else if (!UTIL.isjQueryAvailable() || this.CONFIG.scrollbar === 'native') {\n\n        if (this.drawArea.clientWidth < treeWidth) { // is overflow-x necessary\n          this.drawArea.style.overflowX = \"auto\";\n        }\n\n        if (this.drawArea.clientHeight < treeHeight) { // is overflow-y necessary\n          this.drawArea.style.overflowY = \"auto\"; // Fancy scrollbar relies heavily on jQuery, so guarding with if ( $ );\n        }\n      } else if (this.CONFIG.scrollbar === 'fancy') {\n        var jq_drawArea = $(this.drawArea);\n        if (jq_drawArea.hasClass('ps-container')) {\n          // znaci da je 'fancy' vec inicijaliziran, treba updateat\n          jq_drawArea\n            .find('.Treant')\n            .css({width: viewWidth, height: viewHeight});\n\n          jq_drawArea.perfectScrollbar('update');\n        } else {\n          var mainContainer = jq_drawArea.wrapInner('<div class=\"Treant\"/>'),\n            child = mainContainer.find('.Treant');\n\n          child.css({width: viewWidth, height: viewHeight});\n\n          mainContainer.perfectScrollbar();\n        }\n      } // else this.CONFIG.scrollbar == 'None'\n\n      return this;\n    },\n    /**\n         * @param {TreeNode} treeNode\n         * @param {boolean} hidePoint\n         * @returns {Tree}\n         */\n    setConnectionToParent: function (treeNode, hidePoint) {\n      var stacked = treeNode.stackParentId,\n        connLine,\n        parent = (stacked\n          ? this.nodeDB.get(stacked)\n          : treeNode.parent()),\n\n        pathString = hidePoint\n          ? this.getPointPathString(hidePoint)\n          : this.getPathString(parent, treeNode, stacked);\n\n      if (this.connectionStore[treeNode.id]) {\n        // connector already exists, update the connector geometry\n        connLine = this.connectionStore[treeNode.id];\n        this.animatePath(connLine, pathString);\n      } else {\n        connLine = this\n          ._R\n          .path(pathString);\n        this.connectionStore[treeNode.id] = connLine;\n\n        // don't show connector arrows por pseudo nodes\n        if (treeNode.pseudo) {\n          delete parent.connStyle.style['arrow-end'];\n        }\n        if (parent.pseudo) {\n          delete parent.connStyle.style['arrow-start'];\n        }\n\n        connLine.attr(parent.connStyle.style);\n\n        if (treeNode.drawLineThrough || treeNode.pseudo) {\n          treeNode.drawLineThroughMe(hidePoint);\n        }\n      }\n      treeNode.connector = connLine;\n      return this;\n    },\n\n    /**\n         * Create the path which is represented as a point, used for hiding the connection\n         * A path with a leading \"_\" indicates the path will be hidden\n         * See: http://dmitrybaranovskiy.github.io/raphael/reference.html#Paper.path\n         * @param {object} hidePoint\n         * @returns {string}\n         */\n    getPointPathString: function (hidePoint) {\n      return [\n        \"_M\",\n        hidePoint.x,\n        \",\",\n        hidePoint.y,\n        'L',\n        hidePoint.x,\n        \",\",\n        hidePoint.y,\n        hidePoint.x,\n        \",\",\n        hidePoint.y\n      ].join(' ');\n    },\n\n    /**\n         * This method relied on receiving a valid Raphael Paper.path.\n         * See: http://dmitrybaranovskiy.github.io/raphael/reference.html#Paper.path\n         * A pathString is typically in the format of \"M10,20L30,40\"\n         * @param path\n         * @param {string} pathString\n         * @returns {Tree}\n         */\n    animatePath: function (path, pathString) {\n      if (path.hidden && pathString.charAt(0) !== \"_\") { // path will be shown, so show it\n        path.show();\n        path.hidden = false;\n      }\n\n      // See:\n      // http://dmitrybaranovskiy.github.io/raphael/reference.html#Element.animate\n      path\n        .animate({\n          path: pathString.charAt(0) === \"_\"\n            ? pathString.substring(1)\n            : pathString // remove the \"_\" prefix if it exists\n        }, this.CONFIG.animation.connectorsSpeed, this.CONFIG.animation.connectorsAnimation, function () {\n          if (pathString.charAt(0) === \"_\") { // animation is hiding the path, hide it at the and of animation\n            path.hide();\n            path.hidden = true;\n          }\n        });\n      return this;\n    },\n\n    /**\n         *\n         * @param {TreeNode} from_node\n         * @param {TreeNode} to_node\n         * @param {boolean} stacked\n         * @returns {string}\n         */\n    getPathString: function (from_node, to_node, stacked) {\n      var startPoint = from_node.connectorPoint(true),\n        endPoint = to_node.connectorPoint(false),\n        orientation = this.CONFIG.rootOrientation,\n        connType = from_node.connStyle.type,\n        P1 = {},\n        P2 = {};\n\n      if (orientation === 'NORTH' || orientation === 'SOUTH') {\n        P1.y = P2.y = (startPoint.y + endPoint.y) / 2;\n\n        P1.x = startPoint.x;\n        P2.x = endPoint.x;\n      } else if (orientation === 'EAST' || orientation === 'WEST') {\n        P1.x = P2.x = (startPoint.x + endPoint.x) / 2;\n\n        P1.y = startPoint.y;\n        P2.y = endPoint.y;\n      }\n\n      // sp, p1, pm, p2, ep == \"x,y\"\n      var sp = startPoint.x + ',' + startPoint.y,\n        p1 = P1.x + ',' + P1.y,\n        p2 = P2.x + ',' + P2.y,\n        ep = endPoint.x + ',' + endPoint.y,\n        pm = (P1.x + P2.x) / 2 + ',' + (P1.y + P2.y) / 2,\n        pathString,\n        stackPoint;\n\n      if (stacked) { // STACKED CHILDREN\n\n        stackPoint = (orientation === 'EAST' || orientation === 'WEST')\n          ? endPoint.x + ',' + startPoint.y\n          : startPoint.x + ',' + endPoint.y;\n\n        if (connType === \"step\" || connType === \"straight\") {\n          pathString = [\n            \"M\",\n            sp,\n            'L',\n            stackPoint,\n            'L',\n            ep\n          ];\n        } else if (connType === \"curve\" || connType === \"bCurve\") {\n          var helpPoint, // used for nicer curve lines\n            indent = from_node.connStyle.stackIndent;\n\n          if (orientation === 'NORTH') {\n            helpPoint = (endPoint.x - indent) + ',' + (endPoint.y - indent);\n          } else if (orientation === 'SOUTH') {\n            helpPoint = (endPoint.x - indent) + ',' + (endPoint.y + indent);\n          } else if (orientation === 'EAST') {\n            helpPoint = (endPoint.x + indent) + ',' + startPoint.y;\n          } else if (orientation === 'WEST') {\n            helpPoint = (endPoint.x - indent) + ',' + startPoint.y;\n          }\n          pathString = [\n            \"M\",\n            sp,\n            'L',\n            helpPoint,\n            'S',\n            stackPoint,\n            ep\n          ];\n        }\n\n      } else { // NORMAL CHILDREN\n        if (connType === \"step\") {\n          pathString = [\n            \"M\",\n            sp,\n            'L',\n            p1,\n            'L',\n            p2,\n            'L',\n            ep\n          ];\n        } else if (connType === \"curve\") {\n          pathString = [\n            \"M\",\n            sp,\n            'C',\n            p1,\n            p2,\n            ep\n          ];\n        } else if (connType === \"bCurve\") {\n          pathString = [\n            \"M\",\n            sp,\n            'Q',\n            p1,\n            pm,\n            'T',\n            ep\n          ];\n        } else if (connType === \"straight\") {\n          pathString = [\"M\", sp, 'L', sp, ep];\n        }\n      }\n\n      return pathString.join(\" \");\n    },\n\n    /**\n         * Algorithm works from left to right, so previous processed node will be left neighbour of the next node\n         * @param {TreeNode} node\n         * @param {number} level\n         * @returns {Tree}\n         */\n    setNeighbors: function (node, level) {\n      node.leftNeighborId = this.lastNodeOnLevel[level];\n      if (node.leftNeighborId) {\n        node\n          .leftNeighbor()\n          .rightNeighborId = node.id;\n      }\n      this.lastNodeOnLevel[level] = node.id;\n      return this;\n    },\n\n    /**\n         * Used for calculation of height and width of a level (level dimensions)\n         * @param {TreeNode} node\n         * @param {number} level\n         * @returns {Tree}\n         */\n    calcLevelDim: function (node, level) { // root node is on level 0\n      this.levelMaxDim[level] = {\n        width: Math.max(this.levelMaxDim[level]\n          ? this.levelMaxDim[level].width\n          : 0, node.width),\n        height: Math.max(this.levelMaxDim[level]\n          ? this.levelMaxDim[level].height\n          : 0, node.height)\n      };\n      return this;\n    },\n\n    /**\n         * @returns {Tree}\n         */\n    resetLevelData: function () {\n      this.lastNodeOnLevel = [];\n      this.levelMaxDim = [];\n      return this;\n    },\n\n    /**\n         * @returns {TreeNode}\n         */\n    root: function () {\n      return this\n        .nodeDB\n        .get(0);\n    }\n  };\n\n  /**\n     * NodeDB is used for storing the nodes. Each tree has its own NodeDB.\n     * @param {object} nodeStructure\n     * @param {Tree} tree\n     * @constructor\n     */\n  var NodeDB = function (nodeStructure, tree) {\n    this.reset(nodeStructure, tree);\n  };\n\n  NodeDB.prototype = {\n\n    /**\n         * @param {object} nodeStructure\n         * @param {Tree} tree\n         * @returns {NodeDB}\n         */\n    reset: function (nodeStructure, tree) {\n\n      this.db = [];\n\n      var self = this;\n\n      /**\n             * @param {object} node\n             * @param {number} parentId\n             */\n      function iterateChildren(node, parentId) {\n        var newNode = self.createNode(node, parentId, tree, null);\n\n        if (node.children) {\n          // pseudo node is used for descending children to the next level\n          if (node.childrenDropLevel && node.childrenDropLevel > 0) {\n            while (node.childrenDropLevel--) {\n              // pseudo node needs to inherit the connection style from its parent for\n              // continuous connectors\n              var connStyle = UTIL.cloneObj(newNode.connStyle);\n              newNode = self.createNode('pseudo', newNode.id, tree, null);\n              newNode.connStyle = connStyle;\n              newNode.children = [];\n            }\n          }\n\n          var stack = (node.stackChildren && !self.hasGrandChildren(node))\n            ? newNode.id\n            : null;\n\n          // children are positioned on separate levels, one beneath the other\n          if (stack !== null) {\n            newNode.stackChildren = [];\n          }\n\n          for (var i = 0, len = node.children.length; i < len; i++) {\n            if (stack !== null) {\n              newNode = self.createNode(node.children[i], newNode.id, tree, stack);\n              if ((i + 1) < len) {\n                // last node cant have children\n                newNode.children = [];\n              }\n            } else {\n              iterateChildren(node.children[i], newNode.id);\n            }\n          }\n        }\n      }\n\n      if (tree.CONFIG.animateOnInit) {\n        nodeStructure.collapsed = true;\n      }\n\n      iterateChildren(nodeStructure, -1); // root node\n\n      this.createGeometries(tree);\n\n      return this;\n    },\n\n    /**\n         * @param {Tree} tree\n         * @returns {NodeDB}\n         */\n    createGeometries: function (tree) {\n      var i = this.db.length;\n\n      while (i--) {\n        this\n          .get(i)\n          .createGeometry(tree);\n      }\n      return this;\n    },\n\n    /**\n         * @param {number} nodeId\n         * @returns {TreeNode}\n         */\n    get: function (nodeId) {\n      return this.db[nodeId]; // get TreeNode by ID\n    },\n\n    /**\n         * @param {function} callback\n         * @returns {NodeDB}\n         */\n    walk: function (callback) {\n      var i = this.db.length;\n\n      while (i--) {\n        callback.apply(this, [this.get(i)]);\n      }\n      return this;\n    },\n\n    /**\n         *\n         * @param {object} nodeStructure\n         * @param {number} parentId\n         * @param {Tree} tree\n         * @param {number} stackParentId\n         * @returns {TreeNode}\n         */\n    createNode: function (nodeStructure, parentId, tree, stackParentId) {\n      var node = new TreeNode(nodeStructure, this.db.length, parentId, tree, stackParentId);\n\n      this\n        .db\n        .push(node);\n\n      // skip root node (0)\n      if (parentId >= 0) {\n        var parent = this.get(parentId);\n\n        // todo: refactor into separate private method\n        if (nodeStructure.position) {\n          if (nodeStructure.position === 'left') {\n            parent\n              .children\n              .push(node.id);\n          } else if (nodeStructure.position === 'right') {\n            parent\n              .children\n              .splice(0, 0, node.id);\n          } else if (nodeStructure.position === 'center') {\n            parent\n              .children\n              .splice(Math.floor(parent.children.length / 2), 0, node.id);\n          } else {\n            // edge case when there's only 1 child\n            var position = parseInt(nodeStructure.position);\n            if (parent.children.length === 1 && position > 0) {\n              parent\n                .children\n                .splice(0, 0, node.id);\n            } else {\n              parent\n                .children\n                .splice(Math.max(position, parent.children.length - 1), 0, node.id);\n            }\n          }\n        } else {\n          parent\n            .children\n            .push(node.id);\n        }\n      }\n\n      if (stackParentId) {\n        this\n          .get(stackParentId)\n          .stackParent = true;\n        this\n          .get(stackParentId)\n          .stackChildren\n          .push(node.id);\n      }\n\n      return node;\n    },\n\n    getMinMaxCoord: function (dim, parent, MinMax) { // used for getting the dimensions of the tree, dim = 'X' || 'Y'\n      // looks for min and max (X and Y) within the set of nodes\n      parent = parent || this.get(0);\n\n      MinMax = MinMax || { // start with root node dimensions\n        min: parent[dim],\n        max: parent[dim] + ((dim === 'X')\n          ? parent.width\n          : parent.height)\n      };\n\n      var i = parent.childrenCount();\n\n      while (i--) {\n        var node = parent.childAt(i),\n          maxTest = node[dim] + ((dim === 'X')\n            ? node.width\n            : node.height),\n          minTest = node[dim];\n\n        if (maxTest > MinMax.max) {\n          MinMax.max = maxTest;\n        }\n        if (minTest < MinMax.min) {\n          MinMax.min = minTest;\n        }\n\n        this.getMinMaxCoord(dim, node, MinMax);\n      }\n      return MinMax;\n    },\n\n    /**\n         * @param {object} nodeStructure\n         * @returns {boolean}\n         */\n    hasGrandChildren: function (nodeStructure) {\n      var i = nodeStructure.children.length;\n      while (i--) {\n        if (nodeStructure.children[i].children) {\n          return true;\n        }\n      }\n      return false;\n    }\n  };\n\n  /**\n     * TreeNode constructor.\n     * @param {object} nodeStructure\n     * @param {number} id\n     * @param {number} parentId\n     * @param {Tree} tree\n     * @param {number} stackParentId\n     * @constructor\n     */\n  var TreeNode = function (nodeStructure, id, parentId, tree, stackParentId) {\n    this.reset(nodeStructure, id, parentId, tree, stackParentId);\n  };\n\n  TreeNode.prototype = {\n\n    /**\n         * @param {object} nodeStructure\n         * @param {number} id\n         * @param {number} parentId\n         * @param {Tree} tree\n         * @param {number} stackParentId\n         * @returns {TreeNode}\n         */\n    reset: function (nodeStructure, id, parentId, tree, stackParentId) {\n      this.id = id;\n      this.parentId = parentId;\n      this.treeId = tree.id;\n\n      this.prelim = 0;\n      this.modifier = 0;\n      this.leftNeighborId = null;\n\n      this.stackParentId = stackParentId;\n\n      // pseudo node is a node with width=height=0, it is invisible, but necessary for\n      // the correct positioning of the tree\n      this.pseudo = nodeStructure === 'pseudo' || nodeStructure['pseudo']; // todo: surely if nodeStructure is a scalar then the rest will error:\n\n      this.meta = nodeStructure.meta || {};\n      this.image = nodeStructure.image || null;\n\n      this.link = UTIL.createMerge(tree.CONFIG.node.link, nodeStructure.link);\n\n      this.connStyle = UTIL.createMerge(tree.CONFIG.connectors, nodeStructure.connectors);\n      this.connector = null;\n\n      this.drawLineThrough = nodeStructure.drawLineThrough === false\n        ? false\n        : (nodeStructure.drawLineThrough || tree.CONFIG.node.drawLineThrough);\n\n      this.collapsable = nodeStructure.collapsable === false\n        ? false\n        : (nodeStructure.collapsable || tree.CONFIG.node.collapsable);\n      this.collapsed = nodeStructure.collapsed;\n\n      this.text = nodeStructure.text;\n\n      // '.node' DIV\n      this.nodeInnerHTML = nodeStructure.innerHTML;\n      this.nodeHTMLclass = (tree.CONFIG.node.HTMLclass\n        ? tree.CONFIG.node.HTMLclass\n        : '') + // globally defined class for the nodex\n      (nodeStructure.HTMLclass\n        ? (' ' + nodeStructure.HTMLclass)\n        : ''); // + specific node class\n\n      this.nodeHTMLid = nodeStructure.HTMLid;\n\n      this.children = [];\n\n      return this;\n    },\n\n    /**\n         * @returns {Tree}\n         */\n    getTree: function () {\n      return TreeStore.get(this.treeId);\n    },\n\n    /**\n         * @returns {object}\n         */\n    getTreeConfig: function () {\n      return this\n        .getTree()\n        .CONFIG;\n    },\n\n    /**\n         * @returns {NodeDB}\n         */\n    getTreeNodeDb: function () {\n      return this\n        .getTree()\n        .getNodeDb();\n    },\n\n    /**\n         * @param {number} nodeId\n         * @returns {TreeNode}\n         */\n    lookupNode: function (nodeId) {\n      return this\n        .getTreeNodeDb()\n        .get(nodeId);\n    },\n\n    /**\n         * @returns {Tree}\n         */\n    Tree: function () {\n      return TreeStore.get(this.treeId);\n    },\n\n    /**\n         * @param {number} nodeId\n         * @returns {TreeNode}\n         */\n    dbGet: function (nodeId) {\n      return this\n        .getTreeNodeDb()\n        .get(nodeId);\n    },\n\n    /**\n         * Returns the width of the node\n         * @returns {float}\n         */\n    size: function () {\n      var orientation = this\n        .getTreeConfig()\n        .rootOrientation;\n\n      if (this.pseudo) {\n        // prevents separating the subtrees\n        return (-this.getTreeConfig().subTeeSeparation);\n      }\n\n      if (orientation === 'NORTH' || orientation === 'SOUTH') {\n        return this.width;\n      } else if (orientation === 'WEST' || orientation === 'EAST') {\n        return this.height;\n      }\n    },\n\n    /**\n         * @returns {number}\n         */\n    childrenCount: function () {\n      return ((this.collapsed || !this.children)\n        ? 0\n        : this.children.length);\n    },\n\n    /**\n         * @param {number} index\n         * @returns {TreeNode}\n         */\n    childAt: function (index) {\n      return this.dbGet(this.children[index]);\n    },\n\n    /**\n         * @returns {TreeNode}\n         */\n    firstChild: function () {\n      return this.childAt(0);\n    },\n\n    /**\n         * @returns {TreeNode}\n         */\n    lastChild: function () {\n      return this.childAt(this.children.length - 1);\n    },\n\n    /**\n         * @returns {TreeNode}\n         */\n    parent: function () {\n      return this.lookupNode(this.parentId);\n    },\n\n    /**\n         * @returns {TreeNode}\n         */\n    leftNeighbor: function () {\n      if (this.leftNeighborId) {\n        return this.lookupNode(this.leftNeighborId);\n      }\n    },\n\n    /**\n         * @returns {TreeNode}\n         */\n    rightNeighbor: function () {\n      if (this.rightNeighborId) {\n        return this.lookupNode(this.rightNeighborId);\n      }\n    },\n\n    /**\n         * @returns {TreeNode}\n         */\n    leftSibling: function () {\n      var leftNeighbor = this.leftNeighbor();\n\n      if (leftNeighbor && leftNeighbor.parentId === this.parentId) {\n        return leftNeighbor;\n      }\n    },\n\n    /**\n         * @returns {TreeNode}\n         */\n    rightSibling: function () {\n      var rightNeighbor = this.rightNeighbor();\n\n      if (rightNeighbor && rightNeighbor.parentId === this.parentId) {\n        return rightNeighbor;\n      }\n    },\n\n    /**\n         * @returns {number}\n         */\n    childrenCenter: function () {\n      var first = this.firstChild(),\n        last = this.lastChild();\n\n      return (first.prelim + ((last.prelim - first.prelim) + last.size()) / 2);\n    },\n\n    /**\n         * Find out if one of the node ancestors is collapsed\n         * @returns {*}\n         */\n    collapsedParent: function () {\n      var parent = this.parent();\n      if (!parent) {\n        return false;\n      }\n      if (parent.collapsed) {\n        return parent;\n      }\n      return parent.collapsedParent();\n    },\n\n    /**\n         * Returns the leftmost child at specific level, (initial level = 0)\n         * @param level\n         * @param depth\n         * @returns {*}\n         */\n    leftMost: function (level, depth) {\n      if (level >= depth) {\n        return this;\n      }\n      if (this.childrenCount() === 0) {\n        return;\n      }\n\n      for (var i = 0, n = this.childrenCount(); i < n; i++) {\n        var leftmostDescendant = this\n          .childAt(i)\n          .leftMost(level + 1, depth);\n        if (leftmostDescendant) {\n          return leftmostDescendant;\n        }\n      }\n    },\n\n    // returns start or the end point of the connector line, origin is upper-left\n    connectorPoint: function (startPoint) {\n      var orient = this\n          .Tree()\n          .CONFIG\n          .rootOrientation,\n        point = {};\n\n      if (this.stackParentId) { // return different end point if node is a stacked child\n        if (orient === 'NORTH' || orient === 'SOUTH') {\n          orient = 'WEST';\n        } else if (orient === 'EAST' || orient === 'WEST') {\n          orient = 'NORTH';\n        }\n      }\n\n      // if pseudo, a virtual center is used\n      if (orient === 'NORTH') {\n        point.x = (this.pseudo)\n          ? this.X - this\n            .Tree()\n            .CONFIG\n            .subTeeSeparation / 2\n          : this.X + this.width / 2;\n        point.y = (startPoint)\n          ? this.Y + this.height\n          : this.Y;\n      } else if (orient === 'SOUTH') {\n        point.x = (this.pseudo)\n          ? this.X - this\n            .Tree()\n            .CONFIG\n            .subTeeSeparation / 2\n          : this.X + this.width / 2;\n        point.y = (startPoint)\n          ? this.Y\n          : this.Y + this.height;\n      } else if (orient === 'EAST') {\n        point.x = (startPoint)\n          ? this.X\n          : this.X + this.width;\n        point.y = (this.pseudo)\n          ? this.Y - this\n            .Tree()\n            .CONFIG\n            .subTeeSeparation / 2\n          : this.Y + this.height / 2;\n      } else if (orient === 'WEST') {\n        point.x = (startPoint)\n          ? this.X + this.width\n          : this.X;\n        point.y = (this.pseudo)\n          ? this.Y - this\n            .Tree()\n            .CONFIG\n            .subTeeSeparation / 2\n          : this.Y + this.height / 2;\n      }\n      return point;\n    },\n\n    /**\n         * @returns {string}\n         */\n    pathStringThrough: function () { // get the geometry of a path going through the node\n      var startPoint = this.connectorPoint(true),\n        endPoint = this.connectorPoint(false);\n\n      return [\n        \"M\", startPoint.x + \",\" + startPoint.y,\n        'L',\n        endPoint.x + \",\" + endPoint.y\n      ].join(\" \");\n    },\n\n    /**\n         * @param {object} hidePoint\n         */\n    drawLineThroughMe: function (hidePoint) { // hidepoint se proslijedjuje ako je node sakriven zbog collapsed\n      var pathString = hidePoint\n        ? this\n          .Tree()\n          .getPointPathString(hidePoint)\n        : this.pathStringThrough();\n\n      this.lineThroughMe = this.lineThroughMe || this\n        .Tree()\n        ._R\n        .path(pathString);\n\n      var line_style = UTIL.cloneObj(this.connStyle.style);\n\n      delete line_style['arrow-start'];\n      delete line_style['arrow-end'];\n\n      this\n        .lineThroughMe\n        .attr(line_style);\n\n      if (hidePoint) {\n        this\n          .lineThroughMe\n          .hide();\n        this.lineThroughMe.hidden = true;\n      }\n    },\n\n    addSwitchEvent: function (nodeSwitch) {\n      var self = this;\n      UTIL.addEvent(nodeSwitch, 'click', function (e) {\n        e.preventDefault();\n        if (self.getTreeConfig().callback.onBeforeClickCollapseSwitch.apply(self, [nodeSwitch, e]) === false) {\n          return false;\n        }\n\n        self.toggleCollapse();\n\n        self\n          .getTreeConfig()\n          .callback\n          .onAfterClickCollapseSwitch\n          .apply(self, [nodeSwitch, e]);\n      });\n    },\n\n    /**\n         * @returns {TreeNode}\n         */\n    collapse: function () {\n      if (!this.collapsed) {\n        this.toggleCollapse();\n      }\n      return this;\n    },\n\n    /**\n         * @returns {TreeNode}\n         */\n    expand: function () {\n      if (this.collapsed) {\n        this.toggleCollapse();\n      }\n      return this;\n    },\n\n    /**\n         * @returns {TreeNode}\n         */\n    toggleCollapse: function () {\n      var oTree = this.getTree();\n\n      if (!oTree.inAnimation) {\n        oTree.inAnimation = true;\n\n        this.collapsed = !this.collapsed; // toggle the collapse at each click\n        UTIL.toggleClass(this.nodeDOM, 'collapsed', this.collapsed);\n\n        oTree.positionTree();\n\n        var self = this;\n\n        setTimeout(function () { // set the flag after the animation\n          oTree.inAnimation = false;\n          oTree\n            .CONFIG\n            .callback\n            .onToggleCollapseFinished\n            .apply(oTree, [self, self.collapsed]);\n        }, (oTree.CONFIG.animation.nodeSpeed > oTree.CONFIG.animation.connectorsSpeed)\n          ? oTree.CONFIG.animation.nodeSpeed\n          : oTree.CONFIG.animation.connectorsSpeed);\n      }\n      return this;\n    },\n\n    hide: function (collapse_to_point) {\n      collapse_to_point = collapse_to_point || false;\n\n      var bCurrentState = this.hidden;\n      this.hidden = true;\n\n      this.nodeDOM.style.overflow = 'hidden';\n\n      var tree = this.getTree(),\n        config = this.getTreeConfig(),\n        oNewState = {\n          opacity: 0\n        };\n\n      if (collapse_to_point) {\n        oNewState.left = collapse_to_point.x;\n        oNewState.top = collapse_to_point.y;\n      }\n\n      // if parent was hidden in initial configuration, position the node behind the\n      // parent without animations\n      if (!this.positioned || bCurrentState) {\n        this.nodeDOM.style.visibility = 'hidden';\n        if ($) {\n          $(this.nodeDOM).css(oNewState);\n        } else {\n          this.nodeDOM.style.left = oNewState.left + 'px';\n          this.nodeDOM.style.top = oNewState.top + 'px';\n        }\n        this.positioned = true;\n      } else {\n        // todo: fix flashy bug when a node is manually hidden and tree.redraw is\n        // called.\n        if ($) {\n          $(this.nodeDOM)\n            .animate(oNewState, config.animation.nodeSpeed, config.animation.nodeAnimation, function () {\n              this.style.visibility = 'hidden';\n            });\n        } else {\n          this.nodeDOM.style.transition = 'all ' + config.animation.nodeSpeed + 'ms ease';\n          this.nodeDOM.style.transitionProperty = 'opacity, left, top';\n          this.nodeDOM.style.opacity = oNewState.opacity;\n          this.nodeDOM.style.left = oNewState.left + 'px';\n          this.nodeDOM.style.top = oNewState.top + 'px';\n          this.nodeDOM.style.visibility = 'hidden';\n        }\n      }\n\n      // animate the line through node if the line exists\n      if (this.lineThroughMe) {\n        var new_path = tree.getPointPathString(collapse_to_point);\n        if (bCurrentState) {\n          // update without animations\n          this\n            .lineThroughMe\n            .attr({path: new_path});\n        } else {\n          // update with animations\n          tree.animatePath(this.lineThroughMe, tree.getPointPathString(collapse_to_point));\n        }\n      }\n\n      return this;\n    },\n\n    /**\n         * @returns {TreeNode}\n         */\n    hideConnector: function () {\n      var oTree = this.Tree();\n      var oPath = oTree.connectionStore[this.id];\n      if (oPath) {\n        oPath.animate({\n          'opacity': 0\n        }, oTree.CONFIG.animation.connectorsSpeed, oTree.CONFIG.animation.connectorsAnimation);\n      }\n      return this;\n    },\n\n    show: function () {\n      var bCurrentState = this.hidden;\n      this.hidden = false;\n\n      this.nodeDOM.style.visibility = 'visible';\n\n      var oTree = this.Tree();\n\n      var oNewState = {\n          left: this.X,\n          top: this.Y,\n          opacity: 1\n        },\n        config = this.getTreeConfig();\n\n      // if the node was hidden, update opacity and position\n      if ($) {\n        $(this.nodeDOM)\n          .animate(oNewState, config.animation.nodeSpeed, config.animation.nodeAnimation, function () {\n            // $.animate applies \"overflow:hidden\" to the node, remove it to avoid visual\n            // problems\n            this.style.overflow = \"\";\n          });\n      } else {\n        this.nodeDOM.style.transition = 'all ' + config.animation.nodeSpeed + 'ms ease';\n        this.nodeDOM.style.transitionProperty = 'opacity, left, top';\n        this.nodeDOM.style.left = oNewState.left + 'px';\n        this.nodeDOM.style.top = oNewState.top + 'px';\n        this.nodeDOM.style.opacity = oNewState.opacity;\n        this.nodeDOM.style.overflow = '';\n      }\n\n      if (this.lineThroughMe) {\n        this\n          .getTree()\n          .animatePath(this.lineThroughMe, this.pathStringThrough());\n      }\n\n      return this;\n    },\n\n    /**\n         * @returns {TreeNode}\n         */\n    showConnector: function () {\n      var oTree = this.Tree();\n      var oPath = oTree.connectionStore[this.id];\n      if (oPath) {\n        oPath.animate({\n          'opacity': 1\n        }, oTree.CONFIG.animation.connectorsSpeed, oTree.CONFIG.animation.connectorsAnimation);\n      }\n      return this;\n    }\n  };\n\n  /**\n     * Build a node from the 'text' and 'img' property and return with it.\n     *\n     * The node will contain all the fields that present under the 'text' property\n     * Each field will refer to a css class with name defined as node-{$property_name}\n     *\n     * Example:\n     * The definition:\n     *\n     *   text: {\n     *     desc: \"some description\",\n     *     paragraph: \"some text\"\n     *   }\n     *\n     * will generate the following elements:\n     *\n     *   <p class=\"node-desc\">some description</p>\n     *   <p class=\"node-paragraph\">some text</p>\n     *\n     * @Returns the configured node\n     */\n  TreeNode.prototype.buildNodeFromText = function (node) {\n    // IMAGE\n    if (this.image) {\n      image = document.createElement('img');\n      image.src = this.image;\n      node.appendChild(image);\n    }\n\n    // TEXT\n    if (this.text) {\n      for (var key in this.text) {\n        // adding DATA Attributes to the node\n        if (key.startsWith(\"data-\")) {\n          node.setAttribute(key, this.text[key]);\n        } else {\n\n          var textElement = document.createElement(this.text[key].href\n            ? 'a'\n            : 'p');\n\n          // make an <a> element if required\n          if (this.text[key].href) {\n            textElement.href = this.text[key].href;\n            if (this.text[key].target) {\n              textElement.target = this.text[key].target;\n            }\n          }\n\n          textElement.className = \"node-\" + key;\n          textElement.appendChild(document.createTextNode(this.text[key].val\n            ? this.text[key].val\n            : this.text[key]instanceof Object\n              ? \"'val' param missing!\"\n              : this.text[key]));\n\n          node.appendChild(textElement);\n        }\n      }\n    }\n    return node;\n  };\n\n  /**\n     * Build a node from  'nodeInnerHTML' property that defines an existing HTML element, referenced by it's id, e.g: #someElement\n     * Change the text in the passed node to 'Wrong ID selector' if the referenced element does ot exist,\n     * return with a cloned and configured node otherwise\n     *\n     * @Returns node the configured node\n     */\n  TreeNode.prototype.buildNodeFromHtml = function (node) {\n    // get some element by ID and clone its structure into a node\n    if (this.nodeInnerHTML.charAt(0) === \"#\") {\n      var elem = document.getElementById(this.nodeInnerHTML.substring(1));\n      if (elem) {\n        node = elem.cloneNode(true);\n        node.id += \"-clone\";\n        node.className += \" node\";\n      } else {\n        node.innerHTML = \"<b> Wrong ID selector </b>\";\n      }\n    } else {\n      // insert your custom HTML into a node\n      node.innerHTML = this.nodeInnerHTML;\n    }\n    return node;\n  };\n\n  /**\n     * @param {Tree} tree\n     */\n  TreeNode.prototype.createGeometry = function (tree) {\n    if (this.id === 0 && tree.CONFIG.hideRootNode) {\n      this.width = 0;\n      this.height = 0;\n      return;\n    }\n\n    var drawArea = tree.drawArea,\n      image,\n\n      /////////// CREATE NODE //////////////\n      node = document.createElement(this.link.href\n        ? 'a'\n        : 'div');\n\n    node.className = (!this.pseudo)\n      ? TreeNode.CONFIG.nodeHTMLclass\n      : 'pseudo';\n    if (this.nodeHTMLclass && !this.pseudo) {\n      node.className += ' ' + this.nodeHTMLclass;\n    }\n\n    if (this.nodeHTMLid) {\n      node.id = this.nodeHTMLid;\n    }\n\n    if (this.link.href) {\n      node.href = this.link.href;\n      node.target = this.link.target;\n    }\n\n    if ($) {\n      $(node).data('treenode', this);\n    } else {\n      node.data = {\n        'treenode': this\n      };\n    }\n\n    /////////// BUILD NODE CONTENT //////////////\n    if (!this.pseudo) {\n      node = this.nodeInnerHTML\n        ? this.buildNodeFromHtml(node)\n        : this.buildNodeFromText(node);\n\n      // handle collapse switch\n      if (this.collapsed || (this.collapsable && this.childrenCount() && !this.stackParentId)) {\n        this.createSwitchGeometry(tree, node);\n      }\n    }\n\n    tree\n      .CONFIG\n      .callback\n      .onCreateNode\n      .apply(tree, [this, node]);\n\n    /////////// APPEND all //////////////\n    drawArea.appendChild(node);\n\n    this.width = node.offsetWidth;\n    this.height = node.offsetHeight;\n\n    this.nodeDOM = node;\n\n    tree\n      .imageLoader\n      .processNode(this);\n  };\n\n  /**\n     * @param {Tree} tree\n     * @param {Element} nodeEl\n     */\n  TreeNode.prototype.createSwitchGeometry = function (tree, nodeEl) {\n    nodeEl = nodeEl || this.nodeDOM;\n\n    // safe guard and check to see if it has a collapse switch\n    var nodeSwitchEl = UTIL.findEl('.collapse-switch', true, nodeEl);\n    if (!nodeSwitchEl) {\n      nodeSwitchEl = document.createElement('a');\n      nodeSwitchEl.className = \"collapse-switch\";\n\n      nodeEl.appendChild(nodeSwitchEl);\n      this.addSwitchEvent(nodeSwitchEl);\n      if (this.collapsed) {\n        nodeEl.className += \" collapsed\";\n      }\n\n      tree\n        .CONFIG\n        .callback\n        .onCreateNodeCollapseSwitch\n        .apply(tree, [this, nodeEl, nodeSwitchEl]);\n    }\n    return nodeSwitchEl;\n  };\n\n  // ###########################################      Expose global + default\n  // CONFIG params ###########################################\n\n  Tree.CONFIG = {\n    maxDepth: 100,\n    rootOrientation: 'NORTH', // NORTH || EAST || WEST || SOUTH\n    nodeAlign: 'CENTER', // CENTER || TOP || BOTTOM\n    levelSeparation: 30,\n    siblingSeparation: 30,\n    subTeeSeparation: 30,\n\n    hideRootNode: false,\n\n    animateOnInit: false,\n    animateOnInitDelay: 500,\n\n    padding: 15, // the difference is seen only when the scrollbar is shown\n    scrollbar: 'native', // \"native\" || \"fancy\" || \"None\" (PS: \"fancy\" requires jquery and perfect-scrollbar)\n\n    connectors: {\n      type: 'curve', // 'curve' || 'step' || 'straight' || 'bCurve'\n      style: {\n        stroke: 'black'\n      },\n      stackIndent: 15\n    },\n\n    node: { // each node inherits this, it can all be overridden in node config\n\n      // HTMLclass: 'node', drawLineThrough: false, collapsable: false,\n      link: {\n        target: '_self'\n      }\n    },\n\n    animation: { // each node inherits this, it can all be overridden in node config\n      nodeSpeed: 450,\n      nodeAnimation: 'linear',\n      connectorsSpeed: 450,\n      connectorsAnimation: 'linear'\n    },\n\n    callback: {\n      onCreateNode: function (treeNode, treeNodeDom) {}, // this = Tree\n      onCreateNodeCollapseSwitch: function (treeNode, treeNodeDom, switchDom) {}, // this = Tree\n      onAfterAddNode: function (newTreeNode, parentTreeNode, nodeStructure) {}, // this = Tree\n      onBeforeAddNode: function (parentTreeNode, nodeStructure) {}, // this = Tree\n      onAfterPositionNode: function (treeNode, nodeDbIndex, containerCenter, treeCenter) {}, // this = Tree\n      onBeforePositionNode: function (treeNode, nodeDbIndex, containerCenter, treeCenter) {}, // this = Tree\n      onToggleCollapseFinished: function (treeNode, bIsCollapsed) {}, // this = Tree\n      onAfterClickCollapseSwitch: function (nodeSwitch, event) {}, // this = TreeNode\n      onBeforeClickCollapseSwitch: function (nodeSwitch, event) {}, // this = TreeNode\n      onTreeLoaded: function (rootTreeNode) {} // this = Tree\n    }\n  };\n\n  TreeNode.CONFIG = {\n    nodeHTMLclass: 'node'\n  };\n\n  // ############################################# Makes a JSON chart config out\n  // of Array config #############################################\n\n  var JSONconfig = {\n    make: function (configArray) {\n\n      var i = configArray.length,\n        node;\n\n      this.jsonStructure = {\n        chart: null,\n        nodeStructure: null\n      };\n      //fist loop: find config, find root;\n      while (i--) {\n        node = configArray[i];\n        if (node.hasOwnProperty('container')) {\n          this.jsonStructure.chart = node;\n          continue;\n        }\n\n        if (!node.hasOwnProperty('parent') && !node.hasOwnProperty('container')) {\n          this.jsonStructure.nodeStructure = node;\n          node._json_id = 0;\n        }\n      }\n\n      this.findChildren(configArray);\n\n      return this.jsonStructure;\n    },\n\n    findChildren: function (nodes) {\n      var parents = [0]; // start with a a root node\n\n      while (parents.length) {\n        var parentId = parents.pop(),\n          parent = this.findNode(this.jsonStructure.nodeStructure, parentId),\n          i = 0,\n          len = nodes.length,\n          children = [];\n\n        for (; i < len; i++) {\n          var node = nodes[i];\n          if (node.parent && (node.parent._json_id === parentId)) { // skip config and root nodes\n\n            node._json_id = this.getID();\n\n            delete node.parent;\n\n            children.push(node);\n            parents.push(node._json_id);\n          }\n        }\n\n        if (children.length) {\n          parent.children = children;\n        }\n      }\n    },\n\n    findNode: function (node, nodeId) {\n      var childrenLen,\n        found;\n\n      if (node._json_id === nodeId) {\n        return node;\n      } else if (node.children) {\n        childrenLen = node.children.length;\n        while (childrenLen--) {\n          found = this.findNode(node.children[childrenLen], nodeId);\n          if (found) {\n            return found;\n          }\n        }\n      }\n    },\n\n    getID: (function () {\n      var i = 1;\n      return function () {\n        return i++;\n      };\n    })()\n  };\n\n  /**\n     * Chart constructor.\n     */\n  var Treant = function (jsonConfig, callback, jQuery) {\n    if (jsonConfig instanceof Array) {\n      jsonConfig = JSONconfig.make(jsonConfig);\n    }\n\n    // optional\n    if (jQuery) {\n      $ = jQuery;\n    }\n\n    this.tree = TreeStore.createTree(jsonConfig);\n    this\n      .tree\n      .positionTree(callback);\n  };\n\n  Treant.prototype.destroy = function () {\n    TreeStore.destroy(this.tree.id);\n  };\n\n  /* expose constructor globally */\n  window.Treant = Treant;\n\n})();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./Treant.js\n// module id = 3\n// module chunks = 0"],"sourceRoot":""}